<html>
    <head>
        <link rel="stylesheet" href="http://chester.blog.br/estilo.css"
            type="text/css" />
        <link rel="stylesheet" href="http://chester.blog.br/styles-site.css"
            type="text/css" />
            <title>miniTruco - Documentação do Desenvolvedor</title>
    </head>
    <body style="margin:18px">
        <center>
            <h1>
                miniTruco - Documentação do Desenvolvedor
            </h1>
            <i>Carlos Duarte do Nascimento (Chester), 2005-2007</i>
        </center>

        <h2>
            Introdução
        </h2>

        <p>
            O miniTruco é um jogo de Truco feito para dispositivos móveis que
            possuam J2ME (CLDC) implementando MIDP 1.0 ou superior (em português,
            "celulares com Java"), que também permite jogo via Bluetooth em dispositivos que implemente a JSR-82.
            </p>
        <p>Seu código-fonte está disponível através da
            <a href="http://www.gnu.org/licenses/gpl.txt">General Public
                License (GPL)</a>, sem prejuízo dos <a href="http://www.gnu.org/licenses/gpl-faq.pt.html">direitos</a> de autor
            originais. Você pode obtê-lo na
             <a href="http://code.google.com/p/minitruco/">página do projeto no Google Code</a>, juntamente com esta documentação.
        </p>
        <p>
            O objetivo deste documento é ajudar desenvolvedores Java a baixar,
            instalar, entender e aprimorar este código.
        </p>
 
        <h2>
            Preparação do Ambiente
        </h2>

        <h3>
            Pré-Requisitos
        </h3>
        <p>
            A partir da versão 3, a maior parte dos pré-requisitos (bibliotecas e ferramentas)
            está inclusa no repositório do código. Em conformidade com as licenças destas
            ferramentas, o arquivo <a href="http://minitruco.googlecode.com/svn/trunk/miniTruco/lib/README_LIB_COPYRIGHT.txt">README_LIB_COPYRIGHT.txt</a>
            contém os endereços para o download de suas versões completas (já que o diretório só
            tem os .jar), bem como a descrição do que cada uma delas faz.
        </p>
        <p>
            O único requisito obrigatório que não está lá é o
            <a href="http://java.sun.com">JDK</a>. 
            Não é obrigatório, mas recomendo fortemente usar o
            <a href="http://www.eclipse.org/downloads/">Eclipse</a>
          (3.2 ou superior)      com o plugin
                <a href="http://subclipse.tigris.org/">Subclipse</a>. 
               
                </p><p>
Se você quiser rodar a aplicação num celular
            real, pode ser que precise baixar um toolkit J2ME (WTK). Serve um desses:
      </p>          <ul>
                    <li>
                        Win32/Linux:
                        <a
                            href="http://java.sun.com/products/sjwtoolkit/download-2_2.html">J2ME
                            Wireless Toolkit</a>
                    </li>
                    <li>
                        Mac OS X:
                        <a href="http://mpowers.net/midp-osx/">MIDP for OS X</a>
                    </li>
                    </ul>
        
        <p>
            No restante destas instruções, irei assumir o uso do Eclipse (os
            masoquistas podem se virar sem - basta o editor respeitar o encoding
            ISO-8859-1 e chamar o
            <a href="http://ant.apache.org/">Ant</a> manualmente).
        </p>
        <h3>
            Configurando o ambiente
        </h3>

        <ol>
            <li>
                Instale o JDK, se necessário;
            </li>
            <li>
                Instale o Eclipse (e rode pelo menos uma vez), se necessário;
            </li>
            <li>
                Instale o Subclipse (não é preciso baixar, basta seguir as
                <a href="http://subclipse.tigris.org/install.html">instruções</a>);
            </li>
            <li>
                Na perspectiva
                <i>SVN Repository Explorer</i>, configure o repositório do Subclipse
                no Google Code (a URL é https://minitruco.googlecode.com/svn para
                quem já tem cadastro no Google Code, caso contrário use apenas
                http://. Mais detalhes na
                <a href="http://code.google.com/p/minitruco/">página do projeto
                    no Google Code</a>);
            </li>
            <li>
                Abra a pasta tags, dê um clique com o botão direito sobre a pasta
                com a versão desejada (normalmente a última), e faça um checkout
                <br />
                (se preferir, baixe a última versão em desenvolvimento de
                trunk/miniTruco, mas essa não é garantidaemnte estável);
            </li>

        </ol>

        <h3>
            Verificando a instalação
        </h3>

        <p>
            Se tudo deu certo, você vai ter um projeto, cujo arquivo build.xml permite acionar os targets "executa_emulador" (que compila e roda no Microemulator)
            e o "gera_tudo" (que faz todos os passos para criar o .jar/.jad do jogo). Para este último pode ser preciso alterar o path do WTK no arquivo.
        </p>

        <h2>
            Arquitetura da Aplicação
        </h2>
        
        <p>
            Esta seção dá uma visão geral do papel de cada classe da aplicação. Pressupõe-se
            que o leitor já tenha jogado o miniTruco (conhecer J2ME ajuda um bocado, mas não é
            fundamental neste estágio). Os diagramas foram gerados através do
            <a href="http://jude.change-vision.com/jude-web/product/community.html">Jude/Community</a>,
            e estão no arquivo <a href="miniTruco.jude">miniTruco.jude</a>.
            
        </p>
        <p>Após a sua leitura, o <a href="javadoc/index.html">Javadoc</a>
            fica bem mais palatável, bem como o código-fonte em si (que pode ser descarregado conforme
            as instruções acima, ou, se preferir, <a href="http://minitruco.googlecode.com/svn/tags/">navegado diretamente</a>).
        </p>
   
        <h3>
            Classes Principais
        </h3>   
   
        <p>
        O diagrama (figura 1) mostra como as classes do miniTruco se relacionam (os métodos/atributos estão no Javadoc).
        </p>
        <p>A classe
        <a href="javadoc/mt/MiniTruco.html">MiniTruco</a> é o ponto de entrada. Ela contém a maior parte dos menus, além de
        processar os menus de <a href="javadoc/mt/Mesa.html">Mesa</a> (que é onde a
        ação do jogo é visualizada).
        </p>
        <div width="100%" class="mensagem" style="text-align:center"><br/>
        <img src="figura1.png" border="2">
        <br/>
        Figura 1 - Diagrama de Classes (simplificado)
        <br/>
        </div><br/>
        <p>
        A cada nova partida, um <a href="javadoc/mt/Jogo.html">Jogo</a> é instanciado. Ele atua como controlador do jogo,
        conectado a quatro instâncias de <a href="javadoc/mt/Jogador.html">Jogador</a>. Ele informa a cada Jogador os eventos
        do jogo (início de partida, início de rodada, jogadas efetuadas, de quem é a
        vez, etc.) e recebe os comandos deles (jogar carta, pedir truco, etc.).
        </p>
        <p>Note que estas classes são abstratas (itálico, no diagrama), ou seja,
        os objetos são instanciados como descendentes delas, conforme o tipo de
        jogo. Isso é importante em jogos bluetooth (veremos adiante), mas num jogo "normal"
        uma instância de <a href="javadoc/mt/JogoLocal.html">JogoLocal</a>
         se conecta a um <a href="javadoc/mt/JogadorHumano.html">JogadorHumano</a> e três 
         <a href="javadoc/mt/JogadorCPU.html">JogadorCPU</a>. 
         </p>
         <p>
         O JogadorHumano interage diretamente com a Mesa, reproduzindo visualmente os
         eventos informados por Jogo. Qualquer tipo de Jogador possui até três
         <a href="javadoc/mt/Carta.html">Carta</a>s na mão (sempre geradas a partir de um
         <a href="javadoc/mt/Baralho.html">Baralho</a>, para evitar duplicidade), mas as do
         JogadorHumano desenham a si próprias na Mesa (que conta com a ajuda de um
         <a href="javadoc/mt/Animador.html">Animador</a> para movê-las, piscar os placares e
         animar a tela de abertura.
         </p>
         
         <h3>
            Estratégia da CPU
        </h3>
         
         <p>
         Um jogo de Truco tem sempre quatro jogadores, mas, mesmo via Bluetooth, isso nem
         sempre é possível. Assim, o jogo é completado com até três JogadorCPU, que não
         desenham nada na tela (o JogadorHumano cuida de notificar a Mesa para que ela desenhe
         tanto as cartas dele quanto as dos JogadorCPU).
         </p>
         <p>
         Estes JogadorCPU estão conectados no jogo da mesma forma que o JogadorHumano
         (para o Jogo é indiferente, são todos objetos da classe Jogador).
         Ele não decide como jogar - ao invés disso, delega esta escolha para um objeto
         da classe <a href="javadoc/mt/Estrategia.html">Estrategia</a>.
         </p><p>
         O jogo possui atualmente
         duas delas (<a href="javadoc/mt/EstrategiaWillian.html">EstrategiaWilian</a> e
         <a href="javadoc/mt/EstrategiaSellani.html">EstrategiaSellani</a>, batizadas com
         os nomes dos seus autores), mas qualquer programador pode criar uma estratégia
         cusotmizada - <b>mesmo sem conhecer J2ME</b>, basta entender de Java (e, claro,
         de Truco).
         </p>
         <p>
         Para criar uma estratégia customizada, basta criar uma classe que implemente
         a interface Estratégia (modificar uma das duas acima é uma boa idéia, mas
         talvez você prefira começar do zero).
         </p>
         <p>
         Cada um dos métodos corresponde a uma ação que está sendo solicitada ao JogadorCPU,
         e recebe as informações necessárias para completar a ação.
         </p>
         <p>
         Por exemplo, o método joga() é chamado quando é a vez daquele jogador, e recebe
         um objeto SituacaoJogo contendo as cartas na mão do jogador, as que já foram jogadas,
        as regras do jogo atual, o placar, etc.,  e, baseado nisso, tem que
         retornar qual carta o jogador deve jogar (ou 0 para um pedido de truco).
         </p>
         <p>
         O <a href="javadoc/mt/Estrategia.html">javadoc da interface Estrategia</a> explica com detalhes
         o que cada método recebe e deve fazer. Se você criar uma boa estratégia,
         posso integrá-la no jogo. Quem sabe até dá pra fazer um dia alguma brincadeira online,
         no estilo do <a href="http://robocode.sourceforge.net/">Robocode</a>...
         </p>
         
        <h3>
            Bluetooth
        </h3>
        
        <p>
        Apenas as classes com final "BT" usam a API Bluetooth do celular. Na inicialização,
        a classe MiniTruco verifica se o celular tem Bluetooth (JSR 82), e só neste caso
        disponibiliza o menu. Desta forma, o jogo pode ser instalado em celulares que não
        tenham este feature. 
        </p>
        <p>
        Numa partida bluetooth, um celular atua como servidor, e até três celulares-cliente
        se conectam nele. A oferta/descoberta do serviço é feita pelas classes 
       <a href="javadoc/mt/ServidorBT">ServidorBT</a> e <a href="javadoc/mt/ClienteBT">ClienteBT</a> -
       mas uma vez iniciado o jogo, temos:       
        </p>
        <ul><li>        
        <i>Servidor:</i> Uma instância de JogoLocal se conecta a um JogadorHumano,
        além de um <a href="javadoc/mt/JogadorBT.html">JogadorBT</a> para cada cliente conectado. Os vazios são preenchidos com JogadorCPU;
        </li><li>
        <i>Cliente:</i> Uma instância de <a href="javadoc/mt/JogoBT.html">JogoBT</a>;
        se conecta a um JogadorHumano e três <a href="javadoc/mt/JogadorDummy.html">JogadorDummy</a>.
        </li></ul>
        <p>
        Na figura 2 vemos um exemplo com três celulares: um servidor e dois clientes. No servidor, a
         vaga remanescente é preenchida por um JogadorCPU, e cada celular possui um JogadorHumano 
         representando seu "dono".

        Perceba que o JogadorBT atua como <i>proxy</i> do JogadorHumano no servidor,
         e o JogoBT como <i>proxy</i> do JogoLocal nos clientes. E o mais importante: nenhum dos objetos não-Bluetooth "sabe" que 
        está envolvido num jogo multiplayer - esta é outra a vantagem de ter Jogo e Jogador abstratos!
        </p>
                <div width="100%" class="mensagem" style="text-align:center"><br/>
        <img src="figura2.png" border="2">
        <br/>
        Figura 2 - Colaboração num jogo Bluetooth
        <br/>
        </div><br/>
        <p>
        Esta hierarquia permite que um Jogo trate seus objetos Jogador independente
        do tipo deles (humano, cpu, etc.), e também que o Jogador interaja com um jogo
        sem importar se ele é local ou remoto.
        </p>

        <h2>
            Perguntas Freqüentes (FAQ)
        </h2>

        <p>
            <i>Cadê a versão multiplayer via GPRS?</i>
            <br />
            Desencanei dela (é difícil achar um celular que consiga conectar
            direto num servidor não-http). No trunk você só vai encontrar o
            cliente. Optei por orientar o projeto na direção do Bluetooth.
            <br />
            <br />
            Se alguém quiser assumir essa bola (o desenvolvimento e manter um
            servidor no ar), basta pegar as tags serverV1.0 e v2.02.00 (último
            cliente com suporte a client-server via GPRS).
        </p>
        <p>
            <i>Qual versão do Java devo usar?</i>
            <br />
            Eu usei Java 1.5 (Java 5), mas J2ME pressupõe 1.1, então não devem
            haver problemas em usar o 1.4 ou 1.6 (Java 6).
        </p>

        <p>
            <i>E o Eclipse 3.1?</i>
            <br />
            <strike>Eu desenvolvi 99% do projeto no 3.1, mas atualizei
                para o 3.2 recentemente. O site do Eclipse diz que não rola abrir o
                workspace do 3.2 no 3.1, mas vale tentar se você não puder atualizar
                (mas os refactorings do 3.2 são muito bacanas).</strike> Resposta curta: não.
        </p>

        <p>
            <i>Porque você usa esse bando de tralha (Antenna, Proguard, etc.)
                se o J2ME Wireless Toolkit tem tudo isso?</i>
            <br />
            Porque o kit em questão só roda em Win32/Linux (belo exemplo de
            aplicação 100% Pure Java, Sun), e eu uso Mac. Além disso, as
            ferramentas abertas em questão são, a meu ver, mais focadas e
            eficientes. E com a nova política de libs inclusas, quem usa
            Eclipse ou Ant pode baixar e sair usando, sem depender de
            instalar o WTK.
        </p>

        <p>
            <i>Freqüentes tem acento?</i>
            <br />
            Sim, segundo o
            <a href="http://www.sualingua.com.br/03/03_trema.htm">Prof.
                Moreno</a>.
        </p>


        <h2>
            Dicas e Observações
        </h2>

        <p>
            Você pode rodar o jogo diretamente (aproveitando a compilação que o
            Eclipse faz em /bin), configurando o menu "Run" para chamar a classe
            com.barteo.emulator.app.Main e passando em Arguments a string
            "br.inf.chester.minitruco.cliente.MiniTruco"
        </p>
        
        <p>
            Infelizmente, o MicroEmulator não simula o Bluetooth. Para desenvolver
            este feature eu usei o 
            <a href="http://rococosoft.com/registration_simulator.asp">Impronto Simulator</a> -
            uma excelente ferramenta (mencionada até em <a href="http://developers.sun.com/techtopics/mobility/midp/articles/bluetooth2/">tutoriais de Bluetooth da Sun</a>)
            que conta com uma versão gratuita para uso não-comercial.
            </p>
            <p>Não
            posso distribuir aqui porque a licença de uso é personalizada, mas o link acima
            permite solicitar a mesma, caso alguém queira ver este feature em funcionamento
            e (como eu) não tenha dois celulares.
        </p>

        <h2>
            Avisos Legais
        </h2>
        <p>
            Copyright © 2005-2007 Carlos Duarte do Nascimento (Chester) - cd@pobox.com
            <br />
            Estratégia da CPU (EstrategiaWillian): Copyright © 2006 Willian
            Gigliotti - wgigliotti@gmail.com
            <br />
            Estratégia da CPU (EstrategiaSellani): Copyright © 2006 Leonardo
            Sellani
        </p>
        <p>
            Este programa é um software livre; você pode redistribui-lo e/ou
            modifica-lo dentro dos termos da Licença Pública Geral GNU como
            publicada pela Fundação do Software Livre (FSF); na versão 2 da
            Licença, ou (na sua opnião) qualquer versão.
        </p>
        <p>
            Este programa é distribuido na esperança que possa ser util, mas SEM
            NENHUMA GARANTIA; sem uma garantia implicita de ADEQUAÇÂO a qualquer
            MERCADO ou APLICAÇÃO EM PARTICULAR. Veja a Licença Pública Geral GNU
            para maiores detalhes.
        </p>
        <p>
            Você deve ter recebido uma cópia da Licença Pública Geral GNU junto
            com este programa, se não, escreva para a Fundação do Software
            Livre(FSF) Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301
            USA
        </p>

    </body>
</html>